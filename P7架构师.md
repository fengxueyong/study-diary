# 基础架构篇

![image-20210928094221776](C:\Users\fengxueyong\AppData\Roaming\Typora\typora-user-images\image-20210928094221776.png)



## 网关

问到网关的问题：

- 站在对外的角度：网关是隐藏内部细节，统一入口
- 站在自己的角度：所有与业务无关的通用性功能全部由网关来承担
- 站在对内的视角：对下游的各个业务逻辑做路由转发和负载均衡



## 平台

立体监控平台：提供全方位的，多视角的，多维度的监控

消息中心MQ：MQ

任务调度中心：用来调度任务的管理中心

服务管理平台：服务的管理

请求跟踪平台：跟踪服务链路，服务依赖

日志查询平台：用来定位问题

配置中心：



## 存储层

KV存储/RDBMS/NewSQL/缓存系统



## 基础组件

分布式事务、分布式锁、数据库JDBC。



# RPC框架深入剖析与设计

<img src="C:\Users\fengxueyong\AppData\Roaming\Typora\typora-user-images\image-20210928194911653.png" alt="image-20210928194911653" style="zoom: 67%;" />



##　RPC作用： 

屏蔽组包解包、屏蔽数据发送接收、提高开发效

## PRC核心组成：

序列化/反序列号， 负载均衡和路由，连接管理，远程对象方法代理

RPC调用方式：同步调用和异步调用。



# 配置中心

如果服务A要将数据分发（或通知）到其他服务，一般有几种方式？

![image-20210929113524978](C:\Users\fengxueyong\AppData\Roaming\Typora\typora-user-images\image-20210929113524978.png)



1. **RPC调用，太重，需要考虑失败等各种情况，重发等**
2. **MQ通知，**
3. **http，**
4. **ZK**
5. **配置中心**

注册中心从存储+订阅的功能来看，和配置中心相似，只是他的数据是应用的ip和端口号等数据，服务提供者将数据推到注册中心，服务消费端从注册中心订阅关于应用的配置。 为什么不用配置中心做注册中心，是因为配置中心只关注配置的生命周期，并不关注应用的生命周期。所以注册中心在提供应用的配置管理之外，还要对应用的生命周期进行管理，包括服务的健康检查等等的东西



## 配置的几种做法

1.  放在代码中，或敞亮文件中，需要重新编译
2. 如果放在conf/*
3. 放在DB中
4. 配置中心。

## 本地配置的问题

1. 需要重启
2. 生效慢（不能实时生效）
3. 难以维护

## 配种中心的优点

1. 集中管控
2. 热发布
3. 批量操作
4. 效率提升
5. 维护成功降低
6. 安全性保障

## 好的配置中心产品所具有的功能

1. 配置项管理：

   编辑、

   版本管理、

   热发布、

   灰度发布、

   环境隔离、

   提供api接口

2. 权限管理

   读权限，比如风控的一些配置项，都是需要保密的，

   写权限

3. 审计

   记录用户的操作行为。

## 配置中心是什么？

------

仅从实现角度，配置中心其实就是存储+订阅



## 主流配置中心选型对比



<img src="C:\Users\fengxueyong\AppData\Roaming\Typora\typora-user-images\image-20210929124135266.png" alt="image-20210929124135266" style="zoom:50%;" />





spring cloud config基于git。

spring cloud config无本地缓存，一旦发生网络分区，就会出现问题

spring cloud config需要进行重启



nacos不支持权限管理，不支持灰度发布。



## apollo配置中心剖析

![image-20210929125144671](C:\Users\fengxueyong\AppData\Roaming\Typora\typora-user-images\image-20210929125144671.png)



1. configService和adminService首先把自身注册到注册中心（由MetaService和Eureka组成），
2. portal会从注册中心查找AdminServer，apollo client（嵌入在需要获取配置的应用中）从注册中心查找configServer
3. 负载均衡器将查找服务请求达到Eureka进行服务查找
4. 查找到服务后portal调用adminService进行配置推送，client从configService拉取配置

目前内部的注册中心和ConfigService是打包在一起进行部署的，（简化了部署），在部署注册中心的时候就已经把configService也部署了。

问题：1. adminServer如何将数据推给configService。  2. client是调用configService，如何能将配置及时推给

解答：1. configServer不断扫描配置表（定时扫描）  2. client端长轮训configService，获取配置



### Apollo重要特性

#### 多环境支持

开发环境、测试环境、沙箱环境（很生产一样，但用户是我们自己的用户）、生产环境

<img src="C:\Users\fengxueyong\AppData\Roaming\Typora\typora-user-images\image-20210929151341058.png" alt="image-20210929151341058" style="zoom: 50%;" />



环境之间要做到隔离。

apollo对环境分别部署，物理上就已经进行了隔离。portal只需要ok



#### A把数据x推给B，几种方式

1. push：及时，但是重量，需要找到对方，并且处理失败和重试逻辑，A发起，A负责
2. 通知+拉取：及时，相对轻量， A把事件通知B，A长连接给B，或B用长轮训。 A提供接口
3. Long pull： 及时性基本可行。更轻量
4. 定时pull： 不及时，最轻量，

其实也就是1,3.，4,2只是业务上的实现。

（长轮训：用轻量级的方式模拟出长连接的效果）



![image-20210929201127072](C:\Users\fengxueyong\AppData\Roaming\Typora\typora-user-images\image-20210929201127072.png)



配置更新推送：客户端长轮训实现。---》  **实时性**

新的更新一定要落地到本地文件缓存。---》 **可用性**



#### 客户端长轮训逻辑：



![image-20210929201432919](C:\Users\fengxueyong\AppData\Roaming\Typora\typora-user-images\image-20210929201432919.png)

#### 客户端配置信息获取

![image-20210929201537345](C:\Users\fengxueyong\AppData\Roaming\Typora\typora-user-images\image-20210929201537345.png)



## apollo关键代码解读

![image-20210929201651998](C:\Users\fengxueyong\AppData\Roaming\Typora\typora-user-images\image-20210929201651998.png)



1. 按需拉取：getProperty
2. 定时长轮训获取配置，并通知应用（call业务监听器）



其中：

Locator服务拉取ConfigService服务列表供拉圈变更数据使用，

LongPool为长轮训，定时长轮训获取通知，有通知了就调用configService主动去拉取配置

LocalFileConfigRepository为文件固化。

RemoteConfigRepository好LongPool都要去获取configServer，

LongPool长轮训获取到通知变更后，会call RemoteConfigRepository，他会主动去configServer拉取变更数据；RemoteConfigRepository拉取到更新数据后会call  LocalFilleConfigRepository， LocalFileConfigRepository固化后会调用DefaultConfig继续往前通知，最后会通知业务监听器，这样热发布就到此结束了。







